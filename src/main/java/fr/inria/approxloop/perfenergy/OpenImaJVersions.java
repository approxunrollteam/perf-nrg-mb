package fr.inria.approxloop.perfenergy;

import java.util.Random;

/**
 * Class containing a conceptual version of the loop generated by the compiler.
 * <p>
 * These versions are used to validate the compiler optimization. I other words, the compiled versions
 * must produce the same output as these ones.
 * <p>
 * Created by elmarce on 12/02/17.
 */
public class OpenImaJVersions {

    public float fnum = 5.0f;

    public static class WithData {
        public int height;
        public int width;
        public float[] data;

        public WithData(int height, int width, boolean init) {
            data = new float[71];
            pixels = new float[width][height];
            this.width = width;
            this.height = height;
            if (init) {
                Random r = new Random();
                for (int y = 0; y < height; y++)
                    for (int x = 0; x < width; x++)
                        pixels[y][x] = r.nextFloat();
            }
        }

        public WithData(int height, int width) {
            this(height, width, false);
        }

        public float[][] pixels;
    }

    private final float[] buffer;
    public int MAX_KERNEL_WIDTH = 71;
    private final int halfsize = MAX_KERNEL_WIDTH / 2;
    public int height = 480 * 2;
    public int width = 640 * 2;
    public float norm = 0.8f;

    public WithData image;// = new WithData(0,0);
    public float[][] outp;
    public float[][] bnd;
    public float[][] pixels;
    public float[] kernel;
    public float[] BYTE_TO_FLOAT_LUT;
    public WithData gauss;
    public WithData gaussderiv;
    public float sigma;
    public float truncate;

    //public int gauss.width = 5;



    public int x = 10;
    public int y = 5;


    public OpenImaJVersions() {
        outp = new float[height][width];
        pixels = new float[height][width];
        bnd = new float[height][width];
        gauss = new WithData(halfsize, halfsize);
        gaussderiv = new WithData(halfsize, halfsize);

        image = new WithData(height, width);

        kernel = new float[7];
        sigma = 0.7f;
        truncate = 4.0f;
        BYTE_TO_FLOAT_LUT = new float[256];
        Random r = new Random();
        //@@LOOP BEGIN@@ 
        for (int y = 0; y < height; y++)
            //@@LOOP BEGIN@@ 
            for (int x = 0; x < width; x++) {
                outp[y][x] = r.nextFloat();
                bnd[y][x] = r.nextFloat();
                pixels[y][x] = r.nextFloat();
                image.pixels[x][y] = r.nextFloat();
            }
        buffer = new float[width * height];
    }


    public void benchmarkExtractRoi() {
/*
        //@@LOOP BEGIN@@ 
 for(int r = y, rr = 0; rr < height; r++, rr++)
        {
            //@@LOOP BEGIN@@ 
 for(int c = x, cc = 0; cc < width; c++, cc++)
            {
                if (r < 0 || r >= this.height || c < 0 || c >= this.width)
                    outp[rr][cc] = 0;
                else
                    outp[rr][cc] = pixels[r][c];
            }
        }*/
/*
        //@@LOOP BEGIN@@ 
 for(int r = y, rr = 0; rr < height; r++, rr++)
        {
            //@@LOOP BEGIN@@ 
 for(int c = x, cc = 0; cc < width; c+=2, cc+=2)
            {
                if (r < 0 || r >= this.height || c < 0 || c >= this.width)
                    outp[rr][cc] = 0;
                else
                    outp[rr][cc] = pixels[r][c];
                outp[rr][cc+1] = outp[rr][cc];
            }
        }*/

        //@@LOOP BEGIN@@ 
        for (int r = y, rr = 0; rr < height; r++, rr++) {
            if (r < 0 || r >= height)
                outp[rr][0] = 0;
            else
                outp[rr][0] = pixels[r][x];
            //@@LOOP BEGIN@@ 
            for (int c = x + 2, cc = 2; cc < width; c++, cc++) {
                if (r < 0 || r >= height || c < 0 || c >= width)
                    outp[rr][cc] = 0;
                else
                    outp[rr][cc] = pixels[r][c];
                outp[rr][cc - 1] = 0.5f * (outp[rr][cc] + outp[rr][cc - 1]);
            }
        }
    }





/*        */


    //CONCEPTUALLY, THIS IS WHAT THE LOOP SHOULD DO WHEN in NN:
/*
        //@@LOOP BEGIN@@ 
 for(i = -hw ; i <= hw - 2 ; i+= 2)  {
            int k = i+hw;
            gauss.data[k] = (float) Math.exp(-i*i / (2*sigma*sigma));
            gauss.data[k+1] = gauss.data[k];
        }
        //gauss.data[hw - 1] = (float) Math.exp(-hw*hw / (2*sigma*sigma));
*/




    public void benchmark_org_openimaj_video_tracking_klt_TrackingContext__computeKernels_385() {
        int i;
        //@@LOOP BEGIN@@ 
        for (i = 0; i < gauss.width; i++)
            gaussderiv.data[i] = gaussderiv.data[(i + (((MAX_KERNEL_WIDTH) - gauss.width) / 2))];
    }

    public void benchmark_org_openimaj_video_tracking_klt_TrackingContext__computeKernels_385_PERF() {
        int i;
        //@@LOOP BEGIN@@ 
        for (i = 0; i < gauss.width; i += 2)
            gaussderiv.data[i] = gaussderiv.data[(i + (((MAX_KERNEL_WIDTH) - gauss.width) / 2))];
    }

    public void benchmark_org_openimaj_video_tracking_klt_TrackingContext__computeKernels_385_NN() {
        int i;
        //@@LOOP BEGIN@@ 
        for (i = 0; i < gauss.width - 1; i += 2) {
            gauss.data[i] = gauss.data[i + (MAX_KERNEL_WIDTH - gauss.width) / 2];
            gauss.data[i + 1] = gauss.data[i];
        }
        for (i = gauss.width - 1; i < gauss.width; i ++) {
            gauss.data[i] = gauss.data[i + (MAX_KERNEL_WIDTH - gauss.width) / 2];
        }
    }

    public void benchmark_org_openimaj_video_tracking_klt_TrackingContext__computeKernels_385_MN() {
        int i;
        for (i = 0; i < 1; i++) {
            gauss.data[0] = gauss.data[(MAX_KERNEL_WIDTH - gauss.width) / 2];
        }
        //@@LOOP BEGIN@@ 
        for (i = 2; i < gauss.width; i += 2) {
            gauss.data[i] = gauss.data[i + (MAX_KERNEL_WIDTH - gauss.width) / 2];
            gauss.data[i - 1] = (gauss.data[i] + gauss.data[i - 2]) * 0.5f;
        }
    }

    public int microbenchmarkCount() {
        return 10;
    }
}
