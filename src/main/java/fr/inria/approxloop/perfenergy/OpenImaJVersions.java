package fr.inria.approxloop.perfenergy;

import java.util.Random;

/**
 * Class containing a conceptual version of the loop generated by the compiler.
 * <p>
 * These versions are used to validate the compiler optimization. I other words, the compiled versions
 * must produce the same output as these ones.
 * <p>
 * Created by elmarce on 12/02/17.
 */
public class OpenImaJVersions {

    public float fnum = 5.0f;

    static class WithData {
        int height;
        int width;
        public float[] data;

        public WithData(int height, int width) {
            data = new float[71];
            pixels = new float[width][height];
            this.width = width;
            this.height = height;
        }

        public float[][] pixels;
    }

    private final float[] buffer;
    private final int halfsize;
    public int height = 480 * 2;
    public int width = 640 * 2;
    public float norm = 0.8f;

    public WithData image;// = new WithData(0,0);
    public float[][] outp;
    public float[][] bnd;
    public float[][] pixels;
    public float[] kernel;
    public float[] BYTE_TO_FLOAT_LUT;
    public WithData gauss;
    public WithData gaussderiv;
    public float sigma;
    public float truncate;

    //public int gauss.width = 5;

    public int MAX_KERNEL_WIDTH = 71;

    public int x = 10;
    public int y = 5;


    public OpenImaJVersions() {
        outp = new float[height][width];
        pixels = new float[height][width];
        bnd = new float[height][width];
        halfsize = MAX_KERNEL_WIDTH / 2;
        gauss = new WithData(halfsize, halfsize);
        gaussderiv = new WithData(halfsize, halfsize);

        image = new WithData(height, width);

        kernel = new float[7];
        sigma = 0.7f;
        truncate = 4.0f;
        BYTE_TO_FLOAT_LUT = new float[256];
        Random r = new Random();
        //@@LOOP BEGIN@@ 
        for (int y = 0; y < height; y++)
            //@@LOOP BEGIN@@ 
            for (int x = 0; x < width; x++) {
                outp[y][x] = r.nextFloat();
                bnd[y][x] = r.nextFloat();
                pixels[y][x] = r.nextFloat();
                image.pixels[x][y] = r.nextFloat();
            }
        buffer = new float[width * height];

    }

    public void benchmark_org_openimaj_image_FImage_multiplyInplace_1199() {
        int r = 0;
        //@@LOOP BEGIN@@ 
        for (int c = 0; c < width; c++) {
            pixels[r][c] *= fnum;
        }
    }

    public void benchmark_org_openimaj_image_FImage_multiplyInplace_1199_PERF() {
        int r = 0;
        //@@LOOP BEGIN@@
        //@@LOOP BEGIN@@ 
        for (int c = 0; c < width; c += 2) {
            pixels[r][c] *= fnum;
        }
        //@@END@@
    }

    public void benchmark_org_openimaj_image_FImage_multiplyInplace_1199_MN() {
        int r = 0;
        pixels[r][0] *= fnum;
        //@@LOOP BEGIN@@
        for (int c = 2; c < width - 1; c += 2) {
            pixels[r][c] *= fnum;
            pixels[r][c - 1] = (pixels[r][c] + pixels[r][c - 2]) * 0.5f;
        }
    }

    public void benchmark_org_openimaj_image_FImage_multiplyInplace_1199_NN() {
        int r = 0;
        //@@LOOP BEGIN@@ 
        for (int c = 0; c < width - 1; c += 2) {
            pixels[r][c] *= fnum;
            pixels[r][c + 1] = pixels[r][c];
        }
        for (int c = width - 1; c < width; c += 2) {
            pixels[r][c] *= fnum;
        }
    }

    public void benchmark_org_openimaj_image_MBFImage_flatten_247_PERF() {
        int y = 0;
        //@@LOOP BEGIN@@ 
        for (int c = 0; c < width; c += 2) {
            bnd[y][c] += outp[y][c];
        }
    }

    public void benchmark_org_openimaj_image_MBFImage_flatten_247() {
        int y = 0;
        //@@LOOP BEGIN@@ 
        for (int c = 0; c < width; c++) {
            bnd[y][c] += outp[y][c];
        }
    }

    public void benchmark_org_openimaj_image_MBFImage_flatten_247_NN() {
        int y = 0;
        //@@LOOP BEGIN@@ 
        for (int c = 0; c < width - 1; c += 2) {
            bnd[y][c] += outp[y][c];
            bnd[y][c + 1] += bnd[y][c];
        }
        for (int c = width - 1; c < width; c++) {
            bnd[y][c] += outp[y][c];
        }
    }

    public void benchmark_org_openimaj_image_MBFImage_flatten_247_MN() {
        int y = 0;
        for (int cccc = 0; cccc < 1; cccc++) {
            bnd[y][0] += outp[y][0];
        }
        //@@LOOP BEGIN@@ 
        for (int c = 2; c < width; c += 2) {
            bnd[y][c] += outp[y][c];
            bnd[y][c - 1] = (bnd[y][c] + bnd[y][c - 2]) * 0.5f;
        }
    }

    public void benchmark_org_openimaj_image_MBFImage_flatten_257() {
        //@@LOOP BEGIN@@ 
        for (int x = 0; x < width; x++) {
            outp[y][x] = (outp[y][x] + bnd[y][x]) * norm;
        }
    }

    public void benchmark_org_openimaj_image_MBFImage_flatten_257_PERF() {
        //@@LOOP BEGIN@@ 
        for (int x = 0; x < width; x += 2) {
            outp[y][x] = (outp[y][x] + bnd[y][x]) * norm;
        }
    }

    public void benchmark_org_openimaj_image_MBFImage_flatten_257_NN() {
        //@@LOOP BEGIN@@ 
        for (int x = 0; x < width; x += 2) {
            outp[y][x] = (outp[y][x] + bnd[y][x]) * norm;
            outp[y][x + 1] = outp[y][x];
        }
        for (int x = width - 1; x < width; x++) {
            outp[y][x] = (outp[y][x] + bnd[y][x]) * norm;
        }
    }

    public void benchmark_org_openimaj_image_MBFImage_flatten_257_MN() {
        for (int x = 0; x < 1; x++) {
            outp[y][0] = (outp[y][0] + bnd[y][0]) * norm;
        }
        for (int x = 2; x < width; x += 2) {
            outp[y][x] = (outp[y][x] + bnd[y][x]) * norm;
            outp[y][x - 1] = 0.5f * (outp[y][x - 2] + outp[y][x]);
        }
    }

    public float benchmark_org_openimaj_image_processing_convolution_FGaussianConvolve_makeKernel_106() {
        int ksize = (int) (2.0f * truncate * sigma + 1.0f);
        float sum = 0.0f;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < ksize; i++) {
            final float x = i - ksize / 2;
            kernel[i] = (float) Math.exp(-x * x / (2.0 * sigma * sigma));
            sum += kernel[i];
        }
        return sum;
    }

    public float benchmark_org_openimaj_image_processing_convolution_FGaussianConvolve_makeKernel_106_MN34() {
        int ksize = (int) (2.0f * truncate * sigma + 1.0f);
        float sum = 0.0f;
        //@@LOOP BEGIN@@
        for (int i = 0; i < 1; i++) {
            final float x = i - ksize / 2;
            kernel[i] = (float) Math.exp(-x * x / (2.0 * sigma * sigma));
            sum += kernel[i];
        }
        for (int i = 4; i < ksize - 4; i += 4) {
            final float x = i - ksize / 2;
            kernel[i] = (float) Math.exp(-x * x / (2.0 * sigma * sigma));
            sum += kernel[i];
            kernel[i - 1] = kernel[i - 4] * 0.25f + kernel[i] * 0.75f;
            sum += kernel[i - 1];
            kernel[i - 2] = (kernel[i - 4] + kernel[i]) * 0.5f;
            sum += kernel[i - 2];
            kernel[i - 3] = kernel[i - 4] * 0.75f + kernel[i] * 0.25f;
            sum += kernel[i - 3];
            //System.out.print(".");
        }
        for (int i = ksize - 4; i < ksize; i++) {
            final float x = i - ksize / 2;
            kernel[i] = (float) Math.exp(-x * x / (2.0 * sigma * sigma));
            sum += kernel[i];
        }
        return sum;
    }

    public float benchmark_org_openimaj_image_processing_convolution_FGaussianConvolve_makeKernel_106_NN34() {
        int ksize = (int) (2.0f * truncate * sigma + 1.0f);
        float sum = 0.0f;
        //@@LOOP BEGIN@@
        for (int i = 0; i < ksize - 4; i +=4) {
            final float x = i - ksize / 2;
            kernel[i] = (float) Math.exp(-x * x / (2.0 * sigma * sigma));
            sum += kernel[i];
            kernel[i + 1] = kernel[i];
            sum += kernel[i];
            kernel[i + 2] = kernel[i];
            sum += kernel[i];
            kernel[i + 3] = kernel[i];
            sum += kernel[i];
            ////System.out.print(".");
        }
        for (int i = ksize - 4; i < ksize; i++) {
            final float x = i - ksize / 2;
            kernel[i] = (float) Math.exp(-x * x / (2.0 * sigma * sigma));
            sum += kernel[i];
        }
        return sum;
    }

    public float benchmark_org_openimaj_image_processing_convolution_FGaussianConvolve_makeKernel_106_MN4() {
        int ksize = (int) (2.0f * truncate * sigma + 1.0f);
        float sum = 0.0f;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < ksize - 3; i++) {
            final float x1 = i - ksize / 2;
            kernel[i] = (float) Math.exp(-x1 * x1 / (2.0 * sigma * sigma));
            sum += kernel[i];

            i++;
            final float x2 = i - ksize / 2;
            final float k2 = (float) Math.exp(-x2 * x2 / (2.0 * sigma * sigma));
            kernel[i] = k2;
            sum += kernel[i];

            i += 2;
            final float x4 = i - ksize / 2;
            final float k4 = (float) Math.exp(-x4 * x4 / (2.0 * sigma * sigma));
            kernel[i] = k4;
            sum += kernel[i];

            kernel[i - 1] = (k2 + k4) * 0.5f;
            sum += kernel[i];
        }
        for (int i = ksize - 3; i < ksize; i++) {
            final float x1 = i - ksize / 2;
            kernel[i] = (float) Math.exp(-x1 * x1 / (2.0 * sigma * sigma));
            sum += kernel[i];
        }
        return sum;
    }

    public float benchmark_org_openimaj_image_processing_convolution_FGaussianConvolve_makeKernel_106_NN4() {
        int ksize = (int) (2.0f * truncate * sigma + 1.0f);
        float sum = 0.0f;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < ksize - 3; i++) {
            final float x1 = i - ksize / 2;
            kernel[i] = (float) Math.exp(-x1 * x1 / (2.0 * sigma * sigma));
            sum += kernel[i];

            i++;
            final float x2 = i - ksize / 2;
            kernel[i] = (float) Math.exp(-x2 * x2 / (2.0 * sigma * sigma));
            sum += kernel[i];

            i++;
            final float x3 = i - ksize / 2;
            kernel[i] = (float) Math.exp(-x3 * x3 / (2.0 * sigma * sigma));
            sum += kernel[i];

            i++;
            kernel[i] = kernel[i];
            sum += kernel[i];
        }
        //@@LOOP BEGIN@@ 
        for (int i = ksize - 3; i < ksize; i++) {
            final float x1 = i - ksize / 2;
            kernel[i] = (float) Math.exp(-x1 * x1 / (2.0 * sigma * sigma));
            sum += kernel[i];
        }
        return sum;
    }

    public float benchmark_org_openimaj_image_processing_convolution_FGaussianConvolve_makeKernel_106_PERF() {
        // build kernel
        int ksize = (int) (2.0f * truncate * sigma + 1.0f);
        float sum = 0.0f;

        //@@LOOP BEGIN@@ 
        for (int i = 0; i < ksize; i += 2) {
            final float x = i - ksize / 2;
            kernel[i] = (float) Math.exp(-x * x / (2.0 * sigma * sigma));
            sum += kernel[i];
        }
        return sum;
    }

    public float benchmark_org_openimaj_image_processing_convolution_FGaussianConvolve_makeKernel_106_NN() {
        int ksize = (int) (2.0f * truncate * sigma + 1.0f);
        float sum = 0.0f;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < ksize - 1; i += 2) {
            final float x = i - ksize / 2;
            kernel[i] = (float) Math.exp(-x * x / (2.0 * sigma * sigma));
            sum += kernel[i];
            kernel[i + 1] = kernel[i];
            sum += kernel[i];
        }
        for (int i = ksize - 1; i < ksize; i++) {
            final float x = i - ksize / 2;
            kernel[i] = (float) Math.exp(-x * x / (2.0 * sigma * sigma));
            sum += kernel[i];
        }
        return sum;
    }

    public float benchmark_org_openimaj_image_processing_convolution_FGaussianConvolve_makeKernel_106_MN() {
        int ksize = (int) (2.0f * truncate * sigma + 1.0f);
        float sum = 0.0f;

        for (int i = 0; i < 1; i++) {
            final float xx = 0 - ksize / 2;
            kernel[0] = (float) Math.exp(-xx * xx / (2.0 * sigma * sigma));
            sum += kernel[0];
        }
        //@@LOOP BEGIN@@ 
        for (int i = 2; i < ksize - 1; i += 2) {
            final float x = i - ksize / 2;
            kernel[i] = (float) Math.exp(-x * x / (2.0 * sigma * sigma));
            sum += kernel[i];
            kernel[i - 1] = 0.5f * (kernel[i] + kernel[i - 2]);
            sum += kernel[i];
        }
        for (int i = ksize - 1; i < ksize; i++) {
            final float x = i - ksize / 2;
            kernel[i] = (float) Math.exp(-x * x / (2.0 * sigma * sigma));
            sum += kernel[i];
        }
        return sum;
    }

    public void benchmark_org_openimaj_image_processing_convolution_FGaussianConvolve_makeKernel_113() {
        // build kernel
        int ksize = (int) (2.0f * truncate * sigma + 1.0f);
        float sum = 0.8f;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < ksize; i++) {
            kernel[i] /= sum;
        }
    }

    public void benchmark_org_openimaj_image_processing_convolution_FGaussianConvolve_makeKernel_113_MN() {
        int ksize = (int) (2.0f * truncate * sigma + 1.0f);
        float sum = 0.8f;
        kernel[0] /= sum;
        //@@LOOP BEGIN@@
        for (int i = 0; i < 1; i++) {
            kernel[i] /= sum;
        }
        for (int i = 2; i < ksize; i += 2) {
            kernel[i] /= sum;
            kernel[i - 1] = 0.5f * (kernel[i] + kernel[i - 2]);
        }
    }

    public void benchmark_org_openimaj_image_processing_convolution_FGaussianConvolve_makeKernel_113_PERF() {
        int ksize = (int) (2.0f * truncate * sigma + 1.0f);
        float sum = 0.8f;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < ksize; i += 2) {
            kernel[i] /= sum;
        }
    }

    public void benchmark_org_openimaj_image_processing_convolution_FGaussianConvolve_makeKernel_113_NN() {
        // build kernel
        int ksize = (int) (2.0f * truncate * sigma + 1.0f);
        float sum = 0.8f;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < ksize - 1; i += 2) {
            kernel[i] /= sum;
            kernel[i + 1] = kernel[i];
        }
        for (int i = ksize - 1; i < ksize; i++)
            kernel[i] /= sum;
    }

    public void benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveHorizontal_118_PERF() {
        int r = 5;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < halfsize; i += 2)
            buffer[i] = image.pixels[r][0];
    }

    public void benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveHorizontal_118_NN() {
        int r = 5;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < halfsize - 1; i += 2) {
            buffer[i] = image.pixels[r][0];
            buffer[i + 1] = buffer[i];
        }
        for (int i = halfsize; i < halfsize; i++) {
            buffer[i] = image.pixels[r][0];
        }
    }

    public void benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveHorizontal_118_MN() {
        int r = 5;
        for (int i = 0; i < 1; i++)
            buffer[0] = image.pixels[r][0];
        //@@LOOP BEGIN@@ 
        for (int i = 2; i < halfsize; i += 2) {
            buffer[i] = image.pixels[r][0];
            buffer[i - 1] = 0.5f * (buffer[i] + buffer[i - 2]);
        }
    }

    public void benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveHorizontal_118() {
        int r = 5;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < halfsize; i++)
            buffer[i] = image.pixels[r][0];
    }

    public void benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveHorizontal_120_PERF() {
        int r = 5;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < halfsize; i += 2)
            buffer[(halfsize + i)] = image.pixels[r][i];
    }

    public void benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveHorizontal_120_NN() {
        int r = 5;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < halfsize; i += 2) {
            buffer[(halfsize + i)] = image.pixels[r][i];
            buffer[(halfsize + i) + 1] = buffer[(halfsize + i)];
        }
        for (int i = halfsize; i < halfsize - 1; i++) {
            buffer[(halfsize + i)] = image.pixels[r][i];
        }
    }

    public void benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveHorizontal_120_MN() {
        int r = 5;
        for (int i = 0; i < 1; i++) {
            buffer[(halfsize)] = image.pixels[r][0];
        }
        //@@LOOP BEGIN@@ 
        for (int i = 2; i < halfsize; i += 2) {
            buffer[(halfsize + i)] = image.pixels[r][i];
            buffer[(halfsize + i) - 1] = (buffer[(halfsize + i)] - buffer[(halfsize + i) - 2]) * 0.5f;
        }

    }

    public void benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveHorizontal_120() {
        int r = 5;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < halfsize; i++)
            buffer[(halfsize + i)] = image.pixels[r][i];
    }

    public float[] benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveHorizontal_127() {
        final float buffer[] = new float[width + kernel.length];
        final int l = buffer.length - kernel.length;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < l; i++) {
            float sum = 0.0f;
            //@@LOOP BEGIN@@
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum += buffer[i + j] * kernel[jj];
            buffer[i] = sum;
        }
        return buffer;
    }

    public float[] benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveHorizontal_127_MN34() {
        final float buffer[] = new float[width + kernel.length];
        final int l = buffer.length - kernel.length;
        //@@LOOP BEGIN@@
        for (int i = 0; i < 1; i++) {
            float sum = 0.0f;
            //@@LOOP BEGIN@@
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum += buffer[i + j] * kernel[jj];
            buffer[i] = sum;
        }
        for (int i = 4; i < l - 4; i += 4) {
            float sum = 0.0f;
            //@@LOOP BEGIN@@
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum += buffer[i + j] * kernel[jj];
            buffer[i] = sum;
            buffer[i - 1] = (buffer[i - 4]) * 0.25f + (buffer[i]) * 0.75f;
            buffer[i - 2] = (buffer[i - 4] + buffer[i]) * 0.5f;
            buffer[i - 3] = (buffer[i - 4]) * 0.75f + (buffer[i]) * 0.25f;
            //System.out.print(".");
        }
        for (int i = l - 4; i < l; i++) {
            float sum = 0.0f;
            //@@LOOP BEGIN@@
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum += buffer[i + j] * kernel[jj];
            buffer[i] = sum;
        }
        return buffer;
    }

    public float[] benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveHorizontal_127_NN34() {
        final float buffer[] = new float[width + kernel.length];
        final int l = buffer.length - kernel.length;
        //@@LOOP BEGIN@@
        for (int i = 0; i < l - 4; i += 4) {
            float sum = 0.0f;
            //@@LOOP BEGIN@@
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum += buffer[i + j] * kernel[jj];
            buffer[i] = sum;
            buffer[i + 1] = sum;
            buffer[i + 2] = sum;
            buffer[i + 3] = sum;
            //System.out.print(".");
        }
        for (int i = l - 4; i < l; i++) {
            float sum = 0.0f;
            //@@LOOP BEGIN@@
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum += buffer[i + j] * kernel[jj];
            buffer[i] = sum;
        }
        return buffer;
    }

    public float[] benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveHorizontal_127_PERF() {
        final float buffer[] = new float[width + kernel.length];
        final int l = buffer.length - kernel.length;

        //@@LOOP BEGIN@@ 
        for (int i = 0; i < l; i += 2) {
            float sum = 0.0f;
            //@@LOOP BEGIN@@ 
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum += buffer[i + j] * kernel[jj];
            buffer[i] = sum;
        }
        return buffer;
    }

    public float[] benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveHorizontal_127_NN() {
        final float buffer[] = new float[width + kernel.length];
        final int l = buffer.length - kernel.length;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < l - 1; i += 2) {
            float sum = 0.0f;
            //@@LOOP BEGIN@@ 
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum += buffer[i + j] * kernel[jj];
            buffer[i] = sum;
            buffer[i + 1] = buffer[i] = sum;
        }
        for (int i = l - 1; i < l; i += 2) {
            float sum = 0.0f;
            //@@LOOP BEGIN@@
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum += buffer[i + j] * kernel[jj];
            buffer[i] = sum;
        }
        return buffer;
    }

    public float[] benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveHorizontal_127_NN4() {
        final float buffer[] = new float[width + kernel.length];
        final int l = buffer.length - kernel.length;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < l - 3; i++) {
            float sum1 = 0.0f;
            //@@LOOP BEGIN@@ 
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum1 += buffer[i + j] * kernel[jj];
            buffer[i] = sum1;

            i++;
            float sum2 = 0.0f;
            //@@LOOP BEGIN@@ 
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum2 += buffer[i + j] * kernel[jj];
            buffer[i] = sum2;

            i++;
            float sum3 = 0.0f;
            //@@LOOP BEGIN@@ 
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum3 += buffer[i + j] * kernel[jj];
            buffer[i] = sum3;

            i++;
            buffer[i] = sum3;
        }

        //final float buffer[] = new float[width + kernel.length];
        //final int l = buffer.length - kernel.length;
        //@@LOOP BEGIN@@ 
        for (int i = l - 4; i < l; i++) {
            float sum = 0.0f;
            //@@LOOP BEGIN@@ 
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum += buffer[i + j] * kernel[jj];
            buffer[i] = sum;
        }

        return buffer;
    }

    public float[] benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveHorizontal_127_MN4() {
        final float buffer[] = new float[width + kernel.length];
        final int l = buffer.length - kernel.length;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < l - 3; i++) {
            float sum1 = 0.0f;
            //@@LOOP BEGIN@@ 
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum1 += buffer[i + j] * kernel[jj];
            buffer[i] = sum1;

            i++;
            float sum2 = 0.0f;
            //@@LOOP BEGIN@@ 
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum2 += buffer[i + j] * kernel[jj];
            buffer[i] = sum2;

            i += 2;
            float sum4 = 0.0f;
            //@@LOOP BEGIN@@ 
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum4 += buffer[i + j] * kernel[jj];
            buffer[i] = sum4;

            buffer[i] = (sum4 + sum2) * 0.5f;
        }

        //final float buffer[] = new float[width + kernel.length];
        //final int l = buffer.length - kernel.length;
        //@@LOOP BEGIN@@ 
        for (int i = l - 4; i < l; i++) {
            float sum = 0.0f;
            //@@LOOP BEGIN@@ 
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum += buffer[i + j] * kernel[jj];
            buffer[i] = sum;
        }

        return buffer;
    }

    public float[] benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveHorizontal_127_MN() {
        final float buffer[] = new float[width + kernel.length];
        final int l = buffer.length - kernel.length;
        for (int i = 0; i < 1; i++) {
            float sum = 0.0f;
            //@@LOOP BEGIN@@ 
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum += buffer[j] * kernel[jj];
            buffer[0] = sum;
            buffer[1] = buffer[0] = sum;
        }
        //@@LOOP BEGIN@@ 
        for (int i = 2; i < l; i += 2) {
            float sum = 0.0f;
            //@@LOOP BEGIN@@ 
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum += buffer[i + j] * kernel[jj];
            buffer[i] = sum;
            buffer[i - 1] = 0.5f * (buffer[i] + buffer[i - 2]);
        }/**/
        return buffer;
    }


    public void benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveHorizontal_137() {
        int r = 5;
        //@@LOOP BEGIN@@ 
        for (int c = 0; c < halfsize; c++)
            image.pixels[r][c] = buffer[c];

    }

    public void benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveHorizontal_137_PERF() {
        int r = 5;
        //@@LOOP BEGIN@@ 
        for (int c = 0; c < halfsize; c += 2)
            image.pixels[r][c] = buffer[c];
    }

    public void benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveHorizontal_137_MN() {
        int r = 5;
        for (int i = 0; i < 1; i++)
            image.pixels[r][0] = buffer[0];
        //@@LOOP BEGIN@@ 
        for (int c = 2; c < halfsize; c += 2) {
            image.pixels[r][c] = buffer[c];
            image.pixels[r][c - 1] = 0.5f * (image.pixels[r][c] - image.pixels[r][c - 2]);
        }
    }

    public void benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveHorizontal_137_NN() {
        int r = 5;
        //@@LOOP BEGIN@@ 
        for (int c = 0; c < halfsize - 1; c += 2) {
            image.pixels[r][c] = buffer[c];
            image.pixels[r][c + 1] = image.pixels[r][c];
        }
        for (int c = halfsize - 1; c < halfsize; c++) {
            image.pixels[r][c] = buffer[c];
        }
    }

    public void benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveVertical_157() {
        int c = 5;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < halfsize; i++)
            buffer[i] = image.pixels[0][c];
    }

    public void benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveVertical_157_PERF() {
        int c = 5;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < halfsize; i += 2)
            buffer[i] = image.pixels[0][c];
    }

    public void benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveVertical_157_NN() {
        int c = 5;
        //@@LOOP BEGIN@@ 
        for (int i = halfsize; i < halfsize - 1; i += 2) {
            buffer[i] = image.pixels[0][c];
            buffer[i + 1] = buffer[i];
        }
        for (int i = halfsize - 1; i < halfsize; i += 2) {
            buffer[i] = image.pixels[0][c];
        }
    }

    public void benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveVertical_157_MN() {
        int c = 5;
        for (int i = 0; i < 1; i++)
            buffer[0] = image.pixels[0][0];
        //@@LOOP BEGIN@@ 
        for (int i = 2; i < halfsize; i += 2) {
            buffer[i] = image.pixels[0][c];
            buffer[i - 1] = 0.5f * (buffer[i] + buffer[i - 2]);
        }
    }

    public void benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveVertical_159() {
        int c = 5;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < halfsize; i++)
            buffer[(halfsize + i)] = image.pixels[i][c];
    }

    public void benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveVertical_159_PERF() {
        int c = 5;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < halfsize; i += 2)
            buffer[(halfsize + i)] = image.pixels[i][c];
    }

    public void benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveVertical_159_NN() {
        int c = 5;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < halfsize - 1; i += 2) {
            buffer[(halfsize + i)] = image.pixels[i][c];
            buffer[(halfsize + i) + 1] = buffer[(halfsize + i)];
        }
        for (int i = halfsize; i < halfsize - 1; i++) {
            buffer[(halfsize + i)] = image.pixels[i][c];
        }
    }

    public void benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveVertical_159_MN() {
        int c = 5;
        for (int i = 0; i < 1; i++)
            buffer[(halfsize + 0)] = image.pixels[0][c];
        //@@LOOP BEGIN@@ 
        for (int i = 2; i < halfsize; i += 2) {
            buffer[(halfsize + i)] = image.pixels[i][c];
            buffer[(halfsize + i) - 1] = 0.5f * (buffer[(halfsize + i)] + buffer[(halfsize + i) - 2]);
        }
    }

    public void benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveVertical_161() {
        int c = 5;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < halfsize; i++)
            buffer[halfsize + image.height + i] = image.pixels[image.height - 1][c];
    }

    public void benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveVertical_161_PERF() {
        int c = 5;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < halfsize; i += 2)
            buffer[halfsize + image.height + i] = image.pixels[image.height - 1][c];
    }

    public void benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveVertical_161_NN() {
        int c = 5;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < halfsize - 1; i += 2) {
            int k = halfsize + image.height + i;
            buffer[k] = image.pixels[image.height - 1][c];
            buffer[k + 1] = buffer[k];
        }
        for (int i = halfsize - 1; i < halfsize; i++) {
            int k = halfsize + image.height + i;
            buffer[k] = image.pixels[image.height - 1][c];
        }
    }

    public void benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveVertical_161_MN() {
        int c = 5;
        for (int i = 0; i < 1; i++)
            buffer[halfsize + image.height + i] = image.pixels[image.height - 1][c];
        //@@LOOP BEGIN@@ 
        for (int i = 2; i < halfsize - 1; i += 2) {
            int k = halfsize + image.height + i;
            buffer[k] = image.pixels[image.height - 1][c];
            buffer[k - 1] = 0.5f * (buffer[k] - buffer[k - 2]);
        }
    }

    public float[] benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveVertical_166() {
        final float buffer[] = new float[height + kernel.length];
        final int l = buffer.length - kernel.length;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < l; i++) {
            float sum = 0.0f;
            //@@LOOP BEGIN@@ 
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum += buffer[i + j] * kernel[jj];
            buffer[i] = sum;

        }
        return buffer;
    }

    public float[] benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveVertical_166_MN34() {
        final float buffer[] = new float[height + kernel.length];
        final int l = buffer.length - kernel.length;
        //@@LOOP BEGIN@@
        for (int i = 0; i < 1; i++) {
            float sum = 0.0f;
            //@@LOOP BEGIN@@
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum += buffer[i + j] * kernel[jj];
            buffer[i] = sum;
        }
        for (int i = 4; i < l - 4; i += 4) {
            float sum = 0.0f;
            //@@LOOP BEGIN@@
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum += buffer[i + j] * kernel[jj];
            buffer[i] = sum;
            buffer[i - 1] = (buffer[i - 4]) * 0.25f + (buffer[i]) * 0.75f;
            buffer[i - 2] = (buffer[i - 4] + buffer[i]) * 0.5f;
            buffer[i - 3] = (buffer[i - 4]) * 0.75f + (buffer[i]) * 0.25f;
            //System.out.print(".");
        }
        for (int i = l - 4; i < l; i++) {
            float sum = 0.0f;
            //@@LOOP BEGIN@@
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum += buffer[i + j] * kernel[jj];
            buffer[i] = sum;
        }
        return buffer;
    }

    public float[] benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveVertical_166_NN34() {
        final float buffer[] = new float[height + kernel.length];
        final int l = buffer.length - kernel.length;
        //@@LOOP BEGIN@@
        for (int i = 0; i < l - 4; i += 4) {
            float sum = 0.0f;
            //@@LOOP BEGIN@@
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum += buffer[i + j] * kernel[jj];
            buffer[i] = sum;
            buffer[i + 1] = sum;
            buffer[i + 2] = sum;
            buffer[i + 3] = sum;
            //System.out.print(".");
        }
        for (int i = l - 4; i < l; i++) {
            float sum = 0.0f;
            //@@LOOP BEGIN@@
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum += buffer[i + j] * kernel[jj];
        }
        return buffer;
    }

    public float[] benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveVertical_166_PERF() {
        final float buffer[] = new float[height + kernel.length];
        final int l = buffer.length - kernel.length;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < l; i += 2) {
            float sum = 0.0f;
            //@@LOOP BEGIN@@ 
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum += buffer[i + j] * kernel[jj];
            buffer[i] = sum;
        }
        return buffer;
    }

    public float[] benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveVertical_166_NN() {
        final float buffer[] = new float[height + kernel.length];
        final int l = buffer.length - kernel.length;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < l - 1; i += 2) {
            float sum = 0.0f;
            //@@LOOP BEGIN@@ 
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum += buffer[i + j] * kernel[jj];
            buffer[i] = sum;
            buffer[i + 1] = buffer[i];
        }
        for (int i = l - 1; i < l; i++) {
            float sum = 0.0f;
            //@@LOOP BEGIN@@
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum += buffer[i + j] * kernel[jj];
            buffer[i] = sum;
        }
        return buffer;
    }

    public float[] benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveVertical_166_MN() {
        final float buffer[] = new float[height + kernel.length];
        final int l = buffer.length - kernel.length;
        //@@LOOP BEGIN@@
        for (int i = 0; i < 1; i++) {
            float sum = 0.0f;
            //@@LOOP BEGIN@@
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum += buffer[i + j] * kernel[jj];
            buffer[i] = sum;
        }
        for (int i = 2; i < l; i += 2) {
            float sum = 0.0f;
            //@@LOOP BEGIN@@
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum += buffer[i + j] * kernel[jj];
            buffer[i] = sum;
            buffer[i - 1] = (buffer[i] + buffer[i - 2]) * 0.5f;
        }
        return buffer;
    }

    public float[] benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveVertical_166_NN4() {
        final float buffer[] = new float[height + kernel.length];
        final int l = buffer.length - kernel.length;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < l - 3; i++) {
            float sum1 = 0.0f;
            //@@LOOP BEGIN@@ 
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum1 += buffer[i + j] * kernel[jj];
            buffer[i] = sum1;

            i++;
            float sum2 = 0.0f;
            //@@LOOP BEGIN@@ 
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum2 += buffer[i + j] * kernel[jj];
            buffer[i] = sum2;

            i++;
            float sum3 = 0.0f;
            //@@LOOP BEGIN@@ 
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum3 += buffer[i + j] * kernel[jj];
            buffer[i] = sum3;

            i++;
            buffer[i] = sum3;
        }
        //@@LOOP BEGIN@@ 
        for (int i = l - 4; i < l; i++) {
            float sum = 0.0f;
            //@@LOOP BEGIN@@ 
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum += buffer[i + j] * kernel[jj];
            buffer[i] = sum;
        }
        return buffer;
    }

    public float[] benchmark_org_openimaj_image_processing_convolution_FImageConvolveSeparable_convolveVertical_166_MN4() {
        final float buffer[] = new float[height + kernel.length];
        final int l = buffer.length - kernel.length;
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < l - 3; i += 2) {
            float sum1 = 0.0f;
            //@@LOOP BEGIN@@ 
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum1 += buffer[i + j] * kernel[jj];
            buffer[i] = sum1;

            i++;
            float sum2 = 0.0f;
            //@@LOOP BEGIN@@ 
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum2 += buffer[i + j] * kernel[jj];
            buffer[i] = sum2;

            i++;
            float sum4 = 0.0f;
            //@@LOOP BEGIN@@ 
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum4 += buffer[i + j] * kernel[jj];
            buffer[i] = sum4;

            i++;
            buffer[i] = (sum4 + sum2) * 0.5f;

        }

        //@@LOOP BEGIN@@ 
        for (int i = l - 3; i < l; i += 2) {
            float sum1 = 0.0f;
            //@@LOOP BEGIN@@ 
            for (int j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)
                sum1 += buffer[i + j] * kernel[jj];
            buffer[i] = sum1;
        }

        return buffer;
    }

    public void benchmarkExtractRoi() {
/*
        //@@LOOP BEGIN@@ 
 for(int r = y, rr = 0; rr < height; r++, rr++)
        {
            //@@LOOP BEGIN@@ 
 for(int c = x, cc = 0; cc < width; c++, cc++)
            {
                if (r < 0 || r >= this.height || c < 0 || c >= this.width)
                    outp[rr][cc] = 0;
                else
                    outp[rr][cc] = pixels[r][c];
            }
        }*/
/*
        //@@LOOP BEGIN@@ 
 for(int r = y, rr = 0; rr < height; r++, rr++)
        {
            //@@LOOP BEGIN@@ 
 for(int c = x, cc = 0; cc < width; c+=2, cc+=2)
            {
                if (r < 0 || r >= this.height || c < 0 || c >= this.width)
                    outp[rr][cc] = 0;
                else
                    outp[rr][cc] = pixels[r][c];
                outp[rr][cc+1] = outp[rr][cc];
            }
        }*/

        //@@LOOP BEGIN@@ 
        for (int r = y, rr = 0; rr < height; r++, rr++) {
            if (r < 0 || r >= height)
                outp[rr][0] = 0;
            else
                outp[rr][0] = pixels[r][x];
            //@@LOOP BEGIN@@ 
            for (int c = x + 2, cc = 2; cc < width; c++, cc++) {
                if (r < 0 || r >= height || c < 0 || c >= width)
                    outp[rr][cc] = 0;
                else
                    outp[rr][cc] = pixels[r][c];
                outp[rr][cc - 1] = 0.5f * (outp[rr][cc] + outp[rr][cc - 1]);
            }
        }
    }


    public void benchmark_org_openimaj_image_ImageUtilities_Unknown_117() {
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < BYTE_TO_FLOAT_LUT.length; i++) {
            BYTE_TO_FLOAT_LUT[i] = i / 255f;
        }
    }

    public void benchmark_org_openimaj_image_ImageUtilities_Unknown_117_NN34() {
        //@@LOOP BEGIN@@
        for (int i = 0; i < 1; i++) {
            BYTE_TO_FLOAT_LUT[i] = i / 255f;
        }
        for (int i = 4; i < BYTE_TO_FLOAT_LUT.length - 4; i += 4) {
            BYTE_TO_FLOAT_LUT[i] = i / 255f;
            BYTE_TO_FLOAT_LUT[i - 1] = BYTE_TO_FLOAT_LUT[i];
            BYTE_TO_FLOAT_LUT[i - 2] = BYTE_TO_FLOAT_LUT[i];
            BYTE_TO_FLOAT_LUT[i - 3] = BYTE_TO_FLOAT_LUT[i];
            //System.out.print(".");
        }
        for (int i = BYTE_TO_FLOAT_LUT.length - 4; i < BYTE_TO_FLOAT_LUT.length; i++) {
            BYTE_TO_FLOAT_LUT[i] = i / 255f;
        }
    }

    public void benchmark_org_openimaj_image_ImageUtilities_Unknown_117_MN34() {
        //@@LOOP BEGIN@@
        for (int i = 0; i < 1; i ++) {
            BYTE_TO_FLOAT_LUT[i] = i / 255f;
        }
        for (int i = 4; i < BYTE_TO_FLOAT_LUT.length -4; i += 4) {
            BYTE_TO_FLOAT_LUT[i] = i / 255f;
            BYTE_TO_FLOAT_LUT[i - 1] = BYTE_TO_FLOAT_LUT[i] * 0.75f + BYTE_TO_FLOAT_LUT[i - 4] * 0.25f;
            BYTE_TO_FLOAT_LUT[i - 2] = (BYTE_TO_FLOAT_LUT[i] + BYTE_TO_FLOAT_LUT[i - 4]) * 0.5f;
            BYTE_TO_FLOAT_LUT[i - 3] = BYTE_TO_FLOAT_LUT[i] * 0.25f + BYTE_TO_FLOAT_LUT[i - 4] * 0.75f;
            //System.out.print(".");
        }
        for (int i = BYTE_TO_FLOAT_LUT.length - 4; i < BYTE_TO_FLOAT_LUT.length; i++) {
            BYTE_TO_FLOAT_LUT[i] = i / 255f;
        }
    }

    public void benchmark_org_openimaj_image_ImageUtilities_Unknown_117_PERF() {
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < BYTE_TO_FLOAT_LUT.length; i += 2) {
            BYTE_TO_FLOAT_LUT[i] = i / 255f;
        }
    }

    public void benchmark_org_openimaj_image_ImageUtilities_Unknown_117_NN4() {
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < BYTE_TO_FLOAT_LUT.length - 3; i++) {
            BYTE_TO_FLOAT_LUT[i] = i / 255f;
            i++;
            BYTE_TO_FLOAT_LUT[i] = i / 255f;
            i++;
            BYTE_TO_FLOAT_LUT[i] = i / 255f;
            i++;
            BYTE_TO_FLOAT_LUT[i] = BYTE_TO_FLOAT_LUT[i - 1];
        }
        //@@LOOP BEGIN@@ 
        for (int i = BYTE_TO_FLOAT_LUT.length - 3; i < BYTE_TO_FLOAT_LUT.length; i++) {
            BYTE_TO_FLOAT_LUT[i] = i / 255f;
        }
    }

    public void benchmark_org_openimaj_image_ImageUtilities_Unknown_117_MN4() {
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < BYTE_TO_FLOAT_LUT.length - 3; i++) {
            BYTE_TO_FLOAT_LUT[i] = i / 255f;
            i++;
            float k2 = i / 255f;
            BYTE_TO_FLOAT_LUT[i] = k2;
            i += 2;
            float k4 = i / 255f;
            BYTE_TO_FLOAT_LUT[i] = k4;
            BYTE_TO_FLOAT_LUT[i - 1] = (k4 + k2) * 0.5f;

        }
        //@@LOOP BEGIN@@ 
        for (int i = BYTE_TO_FLOAT_LUT.length - 3; i < BYTE_TO_FLOAT_LUT.length; i++) {
            BYTE_TO_FLOAT_LUT[i] = i / 255f;
        }
    }

    public void benchmark_org_openimaj_image_ImageUtilities_Unknown_117_NN() {
        //@@LOOP BEGIN@@ 
        for (int i = 0; i < BYTE_TO_FLOAT_LUT.length - 1; i += 2) {
            BYTE_TO_FLOAT_LUT[i] = i / 255f;
            BYTE_TO_FLOAT_LUT[i + 1] = BYTE_TO_FLOAT_LUT[i];
        }
        for (int i = 0; i < BYTE_TO_FLOAT_LUT.length; i++) {
            BYTE_TO_FLOAT_LUT[i] = i / 255f;
        }
    }

    public void benchmark_org_openimaj_image_ImageUtilities_Unknown_117_MN() {
        for (int i = 0; i < 1; i++) {
            BYTE_TO_FLOAT_LUT[0] = 0;
        }
        //@@LOOP BEGIN@@ 
        for (int i = 2; i < BYTE_TO_FLOAT_LUT.length; i += 2) {
            BYTE_TO_FLOAT_LUT[i] = i / 255f;
            BYTE_TO_FLOAT_LUT[i - 1] = 0.5f * (BYTE_TO_FLOAT_LUT[i] + BYTE_TO_FLOAT_LUT[i - 2]);
        }
    }

    public void benchmark_org_openimaj_video_tracking_klt_TrackingContext__computeKernels_366() {
        int i;
        final int hw = 71 / 2;
        //@@LOOP BEGIN@@ 
        for (i = -hw; i <= hw; i++) {
            gauss.data[i + hw] = (float) Math.exp(-i * i / (2 * sigma * sigma));
            gaussderiv.data[i + hw] = (-i) * (gauss.data[(i + hw)]);
        }
    }

    //CONCEPTUALLY, THIS IS WHAT THE LOOP SHOULD DO WHEN in MEAN:
    public void benchmark_org_openimaj_video_tracking_klt_TrackingContext__computeKernels_366_MN() {
        int i;
        final int hw = 71 / 2;
        for (i = -hw; i < -hw + 1; i++) {
            gauss.data[i + hw] = (float) Math.exp(-i * i / (2 * sigma * sigma));
            gaussderiv.data[i + hw] = (-i) * (gauss.data[(i + hw)]);
        }
        //@@LOOP BEGIN@@
        for (i = -hw + 2; i <= hw - 1; i += 2) {
            int k = i + hw;
            gauss.data[k] = (float) Math.exp(-i * i / (2 * sigma * sigma));
            gauss.data[k - 1] = (gauss.data[k] + gauss.data[k - 2]) * 0.5f;

            gaussderiv.data[k] = (-i) * (gauss.data[(k)]);
            gaussderiv.data[k - 1] = (gaussderiv.data[k] + gaussderiv.data[k - 2]) * 0.5f;

        }
        for ( i = hw - 1; i <= hw; i++ ) {
            gauss.data[i + hw] = (float) Math.exp(-i * i / (2 * sigma * sigma));
            gaussderiv.data[i + hw] = (-i) * (gauss.data[(i + hw)]);
        }
    }

    public void benchmark_org_openimaj_video_tracking_klt_TrackingContext__computeKernels_366_MN34() {
        int i;
        final int hw = 71 / 2;
        //@@LOOP BEGIN@@
        for (i = -hw; i <= -hw + 1; i++) {
            gauss.data[i + hw] = (float) Math.exp(-i * i / (2 * sigma * sigma));
            gaussderiv.data[i + hw] = (-i) * (gauss.data[(i + hw)]);
        }
        for (i = -hw + 4; i <= hw - 4; i++) {
            float k = (float) Math.exp(-i * i / (2 * sigma * sigma));
            gauss.data[i + hw] = k;
            gauss.data[i + hw - 3] = k * 0.25f + gauss.data[i + hw - 4] * 0.75f;
            gauss.data[i + hw - 2] = (k + gauss.data[i + hw - 4]) * 0.25f;
            gauss.data[i + hw - 1] = (k * 0.75f + gauss.data[i + hw - 4] * 0.25f);
            float kk = (-i) * (gauss.data[(i + hw)]);
            gaussderiv.data[i + hw] = kk;
            gaussderiv.data[i + hw - 3] = kk  * 0.25f + gaussderiv.data[i + hw - 4] * 0.75f;
            gaussderiv.data[i + hw - 2] = (kk + gaussderiv.data[i + hw - 4]) * 0.5f;
            gaussderiv.data[i + hw - 1] = kk  * 0.75f + gaussderiv.data[i + hw - 4] * 0.25f;
            //System.out.print(".");
        }
        for (i = hw - 4; i <= hw; i++) {
            gauss.data[i + hw] = (float) Math.exp(-i * i / (2 * sigma * sigma));
            gaussderiv.data[i + hw] = (-i) * (gauss.data[(i + hw)]);
        }
    }

    public void benchmark_org_openimaj_video_tracking_klt_TrackingContext__computeKernels_366_NN34() {
        int i;
        final int hw = 71 / 2;
        //@@LOOP BEGIN@@
        for (i = -hw; i <= hw - 4; i += 4) {
            float k = (float) Math.exp(-i * i / (2 * sigma * sigma));
            gauss.data[i + hw] = k;
            gauss.data[i + hw] = k;
            gauss.data[i + hw] = k;
            gauss.data[i + hw] = k;
            float kk = (-i) * (gauss.data[(i + hw)]);
            gaussderiv.data[i + hw] = kk;
            gaussderiv.data[i + hw] = kk;
            gaussderiv.data[i + hw] = kk;
            gaussderiv.data[i + hw] = kk;
            //System.out.print(".");
        }
        for (i = hw - 4; i <= hw; i++) {
            float k = (float) Math.exp(-i * i / (2 * sigma * sigma));
            gauss.data[i + hw] = k;
            float kk = (-i) * (gauss.data[(i + hw)]);
            gaussderiv.data[i + hw] = kk;
        }
    }

    public void benchmark_org_openimaj_video_tracking_klt_TrackingContext__computeKernels_366_MN4() {
        int i;
        final int hw = 71 / 2;
        //@@LOOP BEGIN@@ 
        for (i = -hw; i <= hw - 3; i++) {
            gauss.data[i + hw] = (float) Math.exp(-i * i / (2 * sigma * sigma));
            gaussderiv.data[i + hw] = (-i) * (gauss.data[(i + hw)]);

            i++;
            float gd2 = (float) Math.exp(-i * i / (2 * sigma * sigma));
            float gdd2 = (-i) * (gauss.data[(i + hw)]);
            gauss.data[i + hw] = gd2;
            gaussderiv.data[i + hw] = gdd2;

            i += 2;
            float gd4 = (float) Math.exp(-i * i / (2 * sigma * sigma));
            float gdd4 = (-i) * (gauss.data[(i + hw)]);
            gauss.data[i + hw] = gd4;
            gaussderiv.data[i + hw] = gdd4;

            gauss.data[i + hw - 1] = (gd4 + gd2) * 0.5f;
            gaussderiv.data[i + hw - 1] = (gdd4 + gdd2) * 0.5f;
        }
        //@@LOOP BEGIN@@ 
        for (i = hw - 3; i <= hw; i++) {
            gauss.data[i + hw] = (float) Math.exp(-i * i / (2 * sigma * sigma));
            gaussderiv.data[i + hw] = (-i) * (gauss.data[(i + hw)]);
        }
    }

    public void benchmark_org_openimaj_video_tracking_klt_TrackingContext__computeKernels_366_NN4() {
        int i;
        final int hw = 71 / 2;
        //@@LOOP BEGIN@@ 
        for (i = -hw; i <= hw - 3; i++) {
            gauss.data[i + hw] = (float) Math.exp(-i * i / (2 * sigma * sigma));
            gaussderiv.data[i + hw] = (-i) * (gauss.data[(i + hw)]);

            i++;
            gauss.data[i + hw] = (float) Math.exp(-i * i / (2 * sigma * sigma));
            gaussderiv.data[i + hw] = (-i) * (gauss.data[(i + hw)]);

            i++;
            float fg = (float) Math.exp(-i * i / (2 * sigma * sigma));
            float fg1 = (-i) * (gauss.data[(i + hw)]);
            gauss.data[i + hw] = fg;
            gaussderiv.data[i + hw] = fg1;

            i++;
            gauss.data[i + hw] = fg;
            gaussderiv.data[i + hw] = fg1;
        }
        //@@LOOP BEGIN@@ 
        for (i = hw - 3; i <= hw; i++) {
            gauss.data[i + hw] = (float) Math.exp(-i * i / (2 * sigma * sigma));
            gaussderiv.data[i + hw] = (-i) * (gauss.data[(i + hw)]);
        }
    }


    public void benchmark_org_openimaj_video_tracking_klt_TrackingContext__computeKernels_366_PERF() {
        int i;
        final int hw = 71 / 2;
        //@@LOOP BEGIN@@ 
        for (i = -hw; i <= hw; i += 2) {
            gauss.data[i + hw] = (float) Math.exp(-i * i / (2 * sigma * sigma));
            gaussderiv.data[i + hw] = (-i) * (gauss.data[(i + hw)]);
        }
    }

    public void benchmark_org_openimaj_video_tracking_klt_TrackingContext__computeKernels_366_NN() {
        int i;
        final int hw = 71 / 2;
        //@@LOOP BEGIN@@ 
        for (i = -hw; i < hw - 1; i += 2) {
            gauss.data[i + hw] = (float) Math.exp(-i * i / (2 * sigma * sigma));
            gauss.data[i + hw + 1] = gauss.data[i + hw];
            gaussderiv.data[i + hw] = (-i) * (gauss.data[(i + hw)]);
            gaussderiv.data[i + hw + 1] = gaussderiv.data[i + hw];
        }
        for (i = hw - 1; i < hw; i++) {
            gauss.data[i + hw] = (float) Math.exp(-i * i / (2 * sigma * sigma));
            gaussderiv.data[i + hw] = (-i) * (gauss.data[(i + hw)]);
        }
    }


/*        */


    //CONCEPTUALLY, THIS IS WHAT THE LOOP SHOULD DO WHEN in NN:
/*
        //@@LOOP BEGIN@@ 
 for(i = -hw ; i <= hw - 2 ; i+= 2)  {
            int k = i+hw;
            gauss.data[k] = (float) Math.exp(-i*i / (2*sigma*sigma));
            gauss.data[k+1] = gauss.data[k];
        }
        //gauss.data[hw - 1] = (float) Math.exp(-hw*hw / (2*sigma*sigma));
*/


    public void benchmark_org_openimaj_video_tracking_klt_TrackingContext__computeKernels_383() {
        int i;
        //@@LOOP BEGIN@@ 
        for (i = 0; i < gauss.width; i++)
            gauss.data[i] = gauss.data[i + (MAX_KERNEL_WIDTH - gauss.width) / 2];
    }

    public void benchmark_org_openimaj_video_tracking_klt_TrackingContext__computeKernels_383_PERF() {
        int i;
        //@@LOOP BEGIN@@ 
        for (i = 0; i < gauss.width; i += 2)
            gauss.data[i] = gauss.data[i + (MAX_KERNEL_WIDTH - gauss.width) / 2];
    }

    public void benchmark_org_openimaj_video_tracking_klt_TrackingContext__computeKernels_383_NN() {
        int i;
        //@@LOOP BEGIN@@ 
        for (i = 0; i < gauss.width - 1; i += 2) {
            gauss.data[i] = gauss.data[i + (MAX_KERNEL_WIDTH - gauss.width) / 2];
            gauss.data[i + 1] = gauss.data[i];
        }
        for (i = gauss.width - 1; i < gauss.width; i += 2) {
            gauss.data[i] = gauss.data[i + (MAX_KERNEL_WIDTH - gauss.width) / 2];
        }
    }

    public void benchmark_org_openimaj_video_tracking_klt_TrackingContext__computeKernels_383_MN() {
        int i;
        for (i = 0; i < 1; i++) {
            gauss.data[0] = gauss.data[(MAX_KERNEL_WIDTH - gauss.width) / 2];
        }
        //@@LOOP BEGIN@@ 
        for (i = 2; i < gauss.width; i += 2) {
            gauss.data[i] = gauss.data[i + (MAX_KERNEL_WIDTH - gauss.width) / 2];
            gauss.data[i - 1] = (gauss.data[i] + gauss.data[i - 2]) * 0.5f;
        }
    }

    public void benchmark_org_openimaj_video_tracking_klt_TrackingContext__computeKernels_385() {
        int i;
        //@@LOOP BEGIN@@ 
        for (i = 0; i < gauss.width; i++)
            gaussderiv.data[i] = gaussderiv.data[(i + (((MAX_KERNEL_WIDTH) - gauss.width) / 2))];
    }

    public void benchmark_org_openimaj_video_tracking_klt_TrackingContext__computeKernels_385_PERF() {
        int i;
        //@@LOOP BEGIN@@ 
        for (i = 0; i < gauss.width; i += 2)
            gaussderiv.data[i] = gaussderiv.data[(i + (((MAX_KERNEL_WIDTH) - gauss.width) / 2))];
    }

    public void benchmark_org_openimaj_video_tracking_klt_TrackingContext__computeKernels_385_NN() {
        int i;
        //@@LOOP BEGIN@@ 
        for (i = 0; i < gauss.width - 1; i += 2) {
            gauss.data[i] = gauss.data[i + (MAX_KERNEL_WIDTH - gauss.width) / 2];
            gauss.data[i + 1] = gauss.data[i];
        }
        for (i = gauss.width - 1; i < gauss.width; i ++) {
            gauss.data[i] = gauss.data[i + (MAX_KERNEL_WIDTH - gauss.width) / 2];
        }
    }

    public void benchmark_org_openimaj_video_tracking_klt_TrackingContext__computeKernels_385_MN() {
        int i;
        for (i = 0; i < 1; i++) {
            gauss.data[0] = gauss.data[(MAX_KERNEL_WIDTH - gauss.width) / 2];
        }
        //@@LOOP BEGIN@@ 
        for (i = 2; i < gauss.width; i += 2) {
            gauss.data[i] = gauss.data[i + (MAX_KERNEL_WIDTH - gauss.width) / 2];
            gauss.data[i - 1] = (gauss.data[i] + gauss.data[i - 2]) * 0.5f;
        }
    }

    public int microbenchmarkCount() {
        return 10;
    }
}
